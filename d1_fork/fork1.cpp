/**
 * 进程一共有五种状态分别为：创建态，就绪态，运行态，阻塞态(挂起态)，
 * 退出态(终止态)其中创建态和退出态维持的时间是非常短的，稍纵即逝。主要是就绪态, 运行态, 挂起态三者之间的状态切换
 * $ ps aux
	- a: 查看所有终端的信息
	- u: 查看用户相关的信息
	- x: 显示和终端无关的进程信息
 * 
 *获得当前进程id
 *pid_t getpid(void);
 *
 * 获得父进程id
 * pid_t getppid(void);
 * 
 * 创建新进程
 * #include <unistd.h>
 * pid_t fork(void);
 * fork调用会获得一份完整的系统程序镜像，子进程执行fork调用后返回的pid为0，父进程执行后返回的pid是子进程的进程id
 * 注意：
 * 1. 子进程的代码逻辑是独立于父进程的，父进程的代码逻辑不会被子进程所影响。
 * 2. 子进程的代码逻辑执行完毕后，会自动退出。
 * 
 * fork调用后，父子进程的相同点：
*   代码区：默认情况下父子进程地址空间中的源代码始终相同。
*   全局数据区：父进程中的全局变量和变量值全部被拷贝一份放到了子进程地址空间中
*   堆区：父进程中的堆区变量和变量值全部被拷贝一份放到了子进程地址空间中
*   动态库加载区（内存映射区）：父进程中数据信息被拷贝一份放到了子进程地址空间中
*   栈区：父进程中的栈区变量和变量值全部被拷贝一份放到了子进程地址空间中
*   环境变量：默认情况下，父子进程地址空间中的环境变量始终相同。
*   文件描述符表: 父进程中被分配的文件描述符都会拷贝到子进程中，在子进程中可以使用它们打开对应的文件。
* 区别：
*   父子进程各自的虚拟地址空间是相互独立的，不会互相干扰和影响。
*   父子进程地址空间中代码区代码虽然相同，但是父子进程执行的代码逻辑可能是不同的。
*   由于每个进都有自己的进程ID，因此内核区存储的父子进程ID是不同的。
*   fork成功之后，会返回两个值，父子进程的返回值是不同的。根据两个不同的值区分父进程子进程，并执行不同的逻辑。
*
 *当我们需要子进程执行不同的可执行程序时，就需要用到exec函数族
 * exec函数族可以用来执行其他的程序，它将替换当前进程的代码和数据，并从新程序的main函数开始执行。
 * exec族函数中最常用的有两个execl()和execlp()
 *  
 * int execl(const char *path, const char *arg, ...);
 * path: 要启动的可执行程序的路径, 推荐使用绝对路径
 * arg: ps aux 查看进程的时候, 启动的进程的名字, 可以随意指定, 一般和要启动的可执行程序名相同
 * ... : 要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。
 * 函数执行成功, 没有返回值，如果执行失败, 返回 -1。
 * 
 * int execlp(const char *file, const char *arg, ...);
 * file : 可执行程序的名字
 * 在环境变量PATH中，可执行程序可以不加路径
 * 没有在环境变量PATH中, 可执行程序需要指定绝对路径
 * arg: ps aux 查看进程的时候, 启动的进程的名字, 可以随意指定, 一般和要启动的可执行程序名相同
 * ... : 要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。
 * 函数执行成功, 没有返回值，如果执行失败, 返回 -1
 * 
 * 
 * 
 * 
 * 
 * 
 * 
*/
#include <sys/types.h>
#include <unistd.h>
#include <iostream>
#include <stdio.h>

using namespace std;

int main()
{
    //获得当前进程id
    cout << "get current process id: " << getpid() << endl;
    //获得父进程id
    cout << "get current process parent id: " << getppid() << endl;

    //创建子进程
    pid_t pid = fork();
    if(pid == 0)
    {
        //子进程
        cout << "this is child process, pid: " << getpid() << endl;
        //执行exec函数族
        execl("/bin/ls", "ls", "-l", NULL);
    }
    else if(pid > 0)
    {
        //父进程
        cout << "this is parent process, pid: " << getpid() << endl;
        sleep(1);
    }
    else
    {
        //创建失败
        cout << "fork error" << endl;
    }
    return 0;
}